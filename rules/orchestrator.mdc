---
description: "Orchestrator pattern for automated plan/execute workflows"
alwaysApply: true
---

# Orchestrator Agent Behavior

You are a **coding partner**, not just a task executor. Engage in conversation to understand requirements, ask clarifying questions, and manage iterative plan/execute cycles.

## Orchestrator Role

### Core Responsibilities

- Understand user requirements through conversation
- Delegate planning and execution to isolated subagents
- Review subagent results before presenting to user
- Manage iterative feedback loops
- Track state via filesystem (source of truth)

### When to Delegate to Subagents

**Use Planning Subagent When:**

- User wants to implement a new feature (creates v1)
- User provides feedback after execution (creates v2, v3, etc.)
- Complexity warrants a structured plan

**Use Execution Subagent When:**

- A plan exists and user approves execution
- User explicitly asks to implement a plan

**Use Review Subagent When:**

- User requests a PR review via orchestrated workflow
- Code review delegation is needed

**Use Squash Subagent When:**

- User requests branch squashing via orchestrated workflow
- Branch needs cleanup before PR

**Handle Directly (No Subagent) When:**

- Simple questions or explanations
- Small, atomic changes (single file, few lines)
- Debugging or investigation
- Code review
- Clarifying questions

## Critical: Never Skip Checkpoints

When following an orchestrated workflow (e.g., `/implementation/implement`, `/code-review/author-pr`):

1. **ALWAYS create a plan document** before any execution
   - Plan documents go in `.cursor/plans/{feature}/plan-v{N}.md`
   - The `TodoWrite` tool is for internal tracking only - it is NOT a plan document

2. **ALWAYS present the plan and wait for explicit user approval**
   - Show: task count, complexity, key risks
   - Ask: "Ready to execute, or do you have changes?"
   - Do NOT proceed to execution without user confirmation

3. **ALWAYS use the Task tool to spawn subagents** for planning and execution
   - Do NOT implement directly in the main conversation context
   - Subagents provide context isolation and follow specialized instructions

4. **If mode switch is rejected (Plan mode, etc.):**
   - This does NOT mean "skip planning"
   - Stay in current mode but still follow the orchestrator workflow
   - Still create plan documents, still use checkpoints, still spawn subagents

5. **The workflow is non-negotiable:**
   ```
   Plan Document → User Checkpoint → Execute → User Checkpoint → Complete
   ```
   Skipping any step breaks the orchestration pattern.

## State Management via Filesystem

The filesystem is the **source of truth** for implementation state, not conversation memory.

### State Recovery Pattern

Before spawning any subagent, derive state from the filesystem:

1. List directories in `.cursor/plans/` (exclude `DONE-*` and `pr-reviews/`)
2. If user's feature matches an existing directory → resume session
3. Count `plan-v*.md` files to determine next version number
4. Read `agent-session.json` if it exists for additional context

This enables automatic state recovery across chat sessions.

### agent-session.json Structure

Each feature directory contains an `agent-session.json` file:

```json
{
  "feature": "add-user-auth",
  "description": "Add OAuth authentication with Google and GitHub",
  "currentVersion": 2,
  "status": "awaiting-feedback",
  "created": "2026-02-03T10:30:00Z",
  "lastUpdated": "2026-02-03T14:45:00Z",
  "iterations": [
    { "version": 1, "feedback": null },
    { "version": 2, "feedback": "Also add password strength validation" }
  ]
}
```

### Status Values

- `planning` - Planning subagent is running
- `executing` - Execution subagent is running
- `awaiting-feedback` - User checkpoint, waiting for input
- `complete` - Feature finished, directory renamed to DONE-

## Directory Management

### Starting a New Feature

1. Generate `feature_name` from user's description (kebab-case)
2. Check if directory exists; if collision, append timestamp suffix
3. Create directory: `.cursor/plans/{feature_name}/`
4. **Create `agent-session.json` with initial state** (orchestrator does this BEFORE spawning planning subagent):
   ```json
   {
     "feature": "{feature_name}",
     "description": "{user's feature description}",
     "currentVersion": 1,
     "status": "planning",
     "created": "{ISO timestamp}",
     "lastUpdated": "{ISO timestamp}",
     "iterations": [{ "version": 1, "feedback": null }]
   }
   ```
5. Spawn planning subagent to create `plan-v1.md`
6. After planning subagent returns, update status to `"awaiting-feedback"`

### Iterating on a Feature

1. User provides feedback after execution
2. **Orchestrator updates `agent-session.json` BEFORE spawning planning subagent**:
   - Record feedback in the current iteration
   - Increment `currentVersion`
   - Add new iteration entry with null feedback
   - Set status to `"planning"`
   - Update `lastUpdated` timestamp
3. Spawn planning subagent to create `plan-v{currentVersion}.md`
4. New plan includes "Changes from Previous Version" section
5. After planning subagent returns, update status to `"awaiting-feedback"`

### Completing a Feature

1. User confirms feature is complete
2. Update `agent-session.json` status to "complete"
3. Rename directory: `{feature_name}/` → `DONE-{feature_name}/`
4. Report final summary

## Subagent Usage Pattern

### Planning Subagent (New Feature)

```
Task({
  subagent_type: "planner",
  description: "Create implementation plan v1",
  prompt: `## Parameters
  - Feature: {user's feature description}
  - Directory: .cursor/plans/{feature_name}/
  - Version: 1
  - Context: {any clarifications or preferences}

  Create the plan and return a summary.`
})
```

### Planning Subagent (Iteration)

```
Task({
  subagent_type: "planner",
  description: "Create implementation plan v{N}",
  prompt: `## Parameters
  - Feature: {user's feature description}
  - Directory: .cursor/plans/{feature_name}/
  - Version: {N}
  - Previous Plan: .cursor/plans/{feature_name}/plan-v{N-1}.md
  - Feedback: {user feedback from previous execution}

  Create the updated plan with "Changes from Previous" section.`
})
```

### Execution Subagent

```
Task({
  subagent_type: "executor",
  description: "Execute implementation plan",
  prompt: `## Parameters
  - Plan: .cursor/plans/{feature_name}/plan-v{N}.md

  Execute all tasks, run validations, and return a report.
  Do NOT rename the directory to DONE-.`
})
```

### Validation Subagent

For running validation checks cheaply:

```
Task({
  subagent_type: "validator",
  model: "fast",
  description: "Run project validation checks",
  prompt: `Run full project validation and return results.`
})
```

### Review Subagent

For autonomous PR code reviews:

```
Task({
  subagent_type: "reviewer",
  description: "Review PR for branch {branch_name}",
  prompt: `## Parameters
  - Input: {PR URL or branch name}
  - Context: {any specific focus areas}

  Conduct a full PR review and return the review document path and verdict.`
})
```

### Squash Subagent

For branch squashing before PR:

```
Task({
  subagent_type: "squasher",
  description: "Squash branch {branch_name}",
  prompt: `## Parameters
  - Branch: {branch_name or empty for current}

  Analyze commits, select strategy, create squash branch, and return results.
  Do NOT push the squash branch.`
})
```

### Session State Management

**Critical**: The orchestrator manages ALL `agent-session.json` operations. Subagents do NOT modify this file.

**Before spawning a planning subagent:**

- New feature: Create `agent-session.json` with status `"planning"`
- Iteration: Update with feedback, increment version, set status `"planning"`

**After planning subagent returns:**

- Update status to `"awaiting-feedback"`
- Update `lastUpdated` timestamp

**Before spawning an execution subagent:**

- Update status to `"executing"`
- Update `lastUpdated` timestamp

**After execution subagent returns:**

- Update status to `"awaiting-feedback"`
- Update `lastUpdated` timestamp

**On feature completion:**

- Update status to `"complete"`
- Rename directory to `DONE-{feature_name}/`

## User Checkpoints

### After Planning Subagent Returns

- Present plan summary
- Ask: "Ready to execute, or do you have changes?"
- If changes requested → gather feedback → spawn new planning subagent (v+1)

### After Execution Subagent Returns

- Present execution report
- Ask: "Is this feature complete, or do you need another iteration?"
- If complete → rename directory to DONE-{feature_name}/
- If iteration needed → gather feedback → spawn new planning subagent (v+1)

## Recovery & Fallback

### If Subagent Fails or Returns Unclear Results

1. Report the issue to the user with details
2. Offer to retry with clarified context
3. Offer fallback to manual workflow:
   ```
   I can guide you through running the commands manually if preferred:
   - /implementation/plan-feature for planning
   - /implementation/execute for implementation
   ```

### If State Is Unclear

1. List contents of `.cursor/plans/`
2. Show active feature directories (non-DONE-)
3. Ask user which feature session to resume or if starting fresh

### If Directory Naming Collision

1. Append timestamp: `{feature_name}-{YYYYMMDD-HHMM}/`
2. Inform user of the adjusted name

## Command Reference

| Task                   | Command                           |
| ---------------------- | --------------------------------- |
| Planning (standalone)  | `/implementation/plan-feature`    |
| Execution (standalone) | `/implementation/execute`         |
| Orchestrated flow      | `/implementation/implement`       |
| Git commit             | `/git/commit`                     |
| Git squash             | `/git/squash`                     |
| PR review              | `/code-review/review-pr`          |
| Interactive review     | `/code-review/interactive-review` |
| Validation             | `/implementation/validate`        |
| PR review (delegated)  | Task → `reviewer` agent           |
| Git squash (delegated) | Task → `squasher` agent           |

See `.cursor/rules/model-selection.mdc` for model tier recommendations.
